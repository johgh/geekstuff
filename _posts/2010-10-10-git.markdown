---
layout: post
title:  "Git"
permalink:  "git"
date:   2015-07-02 16:30:15
category: Quick Guides
tags: Sysadmin Web
---
> Nota: Cuando se hace referencia a una página (por ej.: p.82), se está haciendo referencia al libro ```Git Pocket Guide(O’Reilly)```


# Terminología

Working tree
: Ficheros que tenemos en el workspace

Index (staging)
: Es el snapshot que será traspasado al ejecutar ```git commit``` a nuestro repositorio local. Cada vez que ejecutamos ```git add``` los ficheros se añaden tal cual están en ese momento, si luego se hacen más cambios sobre los mismos ficheros se deberá volver a ejecutar ```git add```.

> Para saber que hemos subido desde el ```WORKING TREE``` al ```INDEX``` en cada momento y ver las diferencias con el repositorio local ver los comandos ```git difftool``` y ```git difftool --staged``` explicados abajo.

HEAD
: Puntero al último commit.

Master
: Rama creada por defecto (trunk)

Origin
: Repositorio remoto por defecto

> Ver más términos [aquí](https://www.kernel.org/pub/software/scm/git/docs/gitglossary.html)

---

# Publicar cambios

## Workflow centralizado (con merge o rebase)
0) Comprobar si hay cambios en remoto
: ```git fetch``` o ```git pull```

### Si ***no*** hay cambios en remoto:

1) Añadir ficheros al índice para poder hacer commit:
: ```git add . [--all]``` o ```git add file1 [file2] [file3] [...]```

2) Hacer commit de los ficheros que hayamos añadido al índice:
: ```git commit```

3) Publicar los cambios en remoto:
: ```git push```

### Si ***hay*** cambios en remoto:

1) Dejar limpio el índice y el working tree para poder hacer pull:
: 
    * **opción a**: ```git add . [-all]``` + ```git commit```
    * **opción b**: ```git stash```

2) Obtener los cambios realizados en remoto mediante ```git pull [--rebase]```:
: 
    * **escenario a**: No hay conflicto. Automerge commit (o si utilizamos el parámetro ```--rebase``` los nuevos commits quedan añadidos al final)
    * **escenario b**: Hay conflicto. Resolvemos con ```git mergetool``` y ejecutamos ```git commit``` (o ```git rebase --continue```, de haber usado el parámetro ```--rebase```)

2.5) [Opcional]. Si hemos ejecutado ```git stash``` podemos recuperar ahora el stash guardado:
: ```git stash apply```

> Nota: si no queremos todos los cambios del stash, podremos hacer checkout (o diff) de los ficheros que no queramos después de aplicar el stash

3) Comprobar de nuevo si se han producido cambios en remoto:
: ```git pull```

4) Publicar nuestros commits en remoto:
: ```git push```


## Feature Branch Workflow (con rebase)

> El objetivo de este workflow es que la rama master siempre esté a punto para obtener o publicar código.

> La rama `master` nunca debería tener código "inestable". Los desarrolladores deben utilizar ramas `feature` con nombres descriptivos que serán validadas antes de subirse a la rama pública `master`.

> El siguiente workflow sólo prevee hacer merge en el momento de la integración de la rama `feature` con la rama `master`, en los demás casos se ha optado por hacer rebase para no ensuciar el historial de commits.

Configurar git para hacer rebase en lugar de merge al hacer pull
: {% highlight sh %}
    $ git config --global branch.master.rebase yes
    # también podemos configurarlo para todas las ramas
    $ git config --global branch.autosetuprebase always
{% endhighlight %}

Crear rama `feature` y publicarla en remoto
: {% highlight sh %}
    $ git checkout -b feature master
    $ git status
    $ git add <some-file>
    $ git commit
    $ git push -u origin feature
{% endhighlight %}

Propagar cambios de `master` a `feature` (rebase)
: {% highlight sh %}
    $ git checkout feature
    $ git rebase [-i] master
{% endhighlight %}

Propagar cambios de `feature` a `master` (rebase)
: {% highlight sh %}
    # obtenemos en feature los cambios de master
    $ git checkout feature
    $ git rebase master
    # obtenemos en master todos los cambios de feature
    $ git checkout master
    $ git merge feature # fast-forward merge
    # opcional: editamos commits para quedarnos solo con los que necesitemos
    $ git rebase -i
{% endhighlight %}

Deploy de la rama `feature` a `master` (merge)
: {% highlight sh %}
    $ git checkout master
    $ git pull
    $ git fetch origin feature
    $ git merge feature
    $ git branch -d feature
    $ git push
{% endhighlight %}

Reescribir la historia de una rama
: {% highlight sh %}
    # obtener id de commit de la base de una rama
    $ git merge-base feature master
    # hacer rebase pasando por parámetro el id obtenido anteriormente
    $ git rebase -i <id_commit_base>
{% endhighlight %}

> ***IMPORTANTE: Únicamente se debe hacer `rebase -i` de commits que no han sido publicados.***

---

# Configuración

Para ver la configuración actual
: {% highlight sh %}
    $ git config -l
{% endhighlight %}

Para setear valores de la configuración global (o modificar fichero ~/.gitconfig)
: {% highlight sh %}
    $ git config --global user.name "John Doe"
{% endhighlight %}

Store encrypted passwords in Gnome keyring (Only works for https repos. Tested in Ubuntu 14.04)
: {% highlight sh %}
sudo apt-get install libgnome-keyring-dev
cd "`dirname $(locate git-credential-gnome-keyring)`"
make
git config --global credential.helper "`dirname $(locate git-credential-gnome-keyring)`"/git-credential-gnome-keyring
{% endhighlight %}

---

# Iniciar repositorio

Crear repositorio central (--bare), que no será usado directamente
: {% highlight sh %}
$ ssh ares@mars.example.com
ares> git init --bare foo
Initialized empty Git repository in /u/ares/foo/.git
{% endhighlight %}

Para clonar el repositorio y hacer checkout  de la rama ```HEAD``` (normalmente master)
: {% highlight sh %}
    $ git clone ares@mars.example.com:foo
{% endhighlight %}

Conectar directorio con contenido a un nuevo remoto (origen)
: {% highlight sh %}
$ cd foo
$ git init
$ git remote add origin ares@mars.example.com:foo
$ git add .
$ git commit -m 'initial commit'
$ git push -u origin master
{% endhighlight %}

A partir de ahí se puede hacer simplemente
: {% highlight sh %}
    $ git push
{% endhighlight %}

Crear repositorio referencia (para tener varias ramas en checkout, ver p. 82)
: {% highlight sh %}
$ git clone --bare http://foo/bar.git refrep
$ git clone --reference refrep http://foo/bar.git
$ git fetch --all (se deben hacer pulls periódicamente!!)
{% endhighlight %}

---

# Ignorar ficheros

Ficheros .gitignore con los ficheros a ignorar (ver sintáxis en p.44)
: Se pueden colocar en todo el ```WORKING TREE``` (si se comitean se comparten ficheros ignorados)

Ignorar ficheros por repositorio (no se comparten ignores con nadie)
: Fichero .git/info/exclude

Fichero de configuración con ignores (se puede compartir fichero entre varios repositorios de la misma máquina)
: {% highlight sh %}
    $ git config --global core.excludesfile ~/.gitignore
{% endhighlight %}

Ignorar cambios en ficheros tracked (todos los anteriores son para ficheros untracked)
: {% highlight sh %}
    $ git update-index --assume-unchanged
{% endhighlight %}

---

# Comparación de ficheros

## Comparación entre “branches”

Comparación entre ```WORKING TREE``` y ```INDEX```
: {% highlight sh %}
    $ git difftool
{% endhighlight %}

Comparación entre ```INDEX``` y ```HEAD```
: {% highlight sh %}
    $ git difftool --staged
{% endhighlight %}

Comparación entre ```WORKING TREE``` y ```HEAD```
: {% highlight sh %}
    $ git difftool HEAD
{% endhighlight %}

Comparación entre ```WORKING TREE``` y remoto
: {% highlight sh %}
    $ git difftool origin/master
{% endhighlight %}

Comparación entre branches
: {% highlight sh %}
    $ git difftool origin/master origin/branch1
{% endhighlight %}

## Comparación entre commits

Para ver todos los commits del repositorio actual
: {% highlight sh %}
    $ git log
{% endhighlight %}

Para ver todos los commits de un fichero específico
: {% highlight sh %}
    $ git log <fichero>
{% endhighlight %}

Comparar entre el ```WORKING TREE``` y un commit anterior
: {% highlight sh %}
    $ git difftool <hash_commit_anterior>
{% endhighlight %}

Comparación entre 2 commits
: {% highlight sh %}
    $ git difftool <hash_commit1> <hash_commit2>
{% endhighlight %}

---

# Operaciones con INDEX

Añadir al índice cambios parciales de ficheros (se eligen de forma interactiva)
: {% highlight sh %}
    $ git add -p
{% endhighlight %}

Añadir todos los ficheros excepto nuevos (incluye modificados y eliminados)
: {% highlight sh %}
    $ git add -u
{% endhighlight %}

git commit -a , equivale a
: {% highlight sh %}
    $ git add -u; git commit;
{% endhighlight %}

Añadir todo (incluyendo ficheros nuevos, untracked)
: {% highlight sh %}
    $ git add -A
{% endhighlight %}

Borrar/mover fichero de ```WORKING TREE``` y del ```INDEX```
: {% highlight sh %}
$ git rm <filename>
$ git mv <filename>
{% endhighlight %}

Unstage de todos los cambios subidos al ```INDEX```
: {% highlight sh %}
    $ git reset
{% endhighlight %}

Borrar un fichero del ```INDEX```
: {% highlight sh %}
    $ git reset <fichero>
{% endhighlight %}

Borrar cambios parciales (opuesto a git add -p)
: {% highlight sh %}
    $ git reset --patch
{% endhighlight %}

---

# Operaciones con HEAD

## Commits

Ver historial de commits
: {% highlight sh %}
$ git log [<fichero>]
$ git log --graph --oneline --decorate
{% endhighlight %}

Ver donde apunta ```HEAD``` (commit y rama)
: {% highlight sh %}
    $ git show-ref
{% endhighlight %}

Commit incluyendo mensaje de commit
: {% highlight sh %}
    $ git commit -m <mensaje>
{% endhighlight %}

Comitear un directorio vacío
: En git solo se puede hacer commit de ficheros.
Workaround: subir un directorio con un único fichero .gitignore en su interior

<br />

## Descartar cambios

Descartar todos los cambios del ```WORKING TREE``` ("SVN revert")
: {% highlight sh %}
$ git reset --hard
# o lo que es lo mismo:
$ git checkout -f
{% endhighlight %}

Checkout de ```HEAD``` al ```WORKING TREE``` de un fichero específico ("SVN revert")
: {% highlight sh %}
    $ [git reset HEAD <filename>] ; git checkout [--] <filename>
{% endhighlight %}
> “--” no es necesario siempre y cuando no exista una rama con el mismo nombre

Volver temporalmente a un commit antiguo (detached HEAD mode)
: {% highlight sh %}
$ git checkout <commit>
# para volver al commit/rama actual
$ git checkout master
{% endhighlight %}

Descartar definitivamente los cambios locales hasta cierto commit
: {% highlight sh %}
    $ git reset --hard <commit>
{% endhighlight %}
> Esto solo es aconsejable si no se han publicado los commits mediante push, en caso contrario se aconseja usar el comando `git revert` (ver más abajo) que no modifica la historia sino que añade nuevos commits indicando la "vuelta atrás"

Descartar definitivamente los cambios hasta el último commit publicado
: {% highlight sh %}
    $ git fetch [origin master]
    $ git reset --hard FETCH_HEAD
    $ [git clean -df]
{% endhighlight %}
> Obtenemos la referencia del último commit en remoto `FETCH_HEAD` para luego descartar los cambios mediante `get reset --hard`

> `git clean -df` elimina los ficheros untracked, para obtener un repositorio limpio tal y como lo encontraríamos tras hacer `git clone`

<br />

## Merge commit
Cambiar a la rama donde realizar merge commit
: {% highlight sh %}
    $ git checkout <rama>
{% endhighlight %}

Realizar merge commit
: {% highlight sh %}
    $ git merge <rama con_la_que_mezclar_nuestra_rama>
{% endhighlight %}

Realizar merge commit pero no dejar constancia del mismo en el grafo de commits (aparecerá como un commit más de nuestra rama, no tendrá 2 padres)
: {% highlight sh %}
    $ git merge --squash
{% endhighlight %}

Abortar el merge si hay conflictos y no queremos continuar
: {% highlight sh %}
    $ git merge --abort
{% endhighlight %}

<br />

## Pull with rebase
> Se hace pull with rebase para evitar hacer merges "innecesarios" (aquellos que no estén mezclando líneas de trabajo distintas sino que sean simplemente producto de “timing” al hacer commit varios desarrolladores)

Obtener cambios e incorporar nuestros commits encima del resto de commits obtenidos
: {% highlight sh %}
    $ git pull --rebase
{% endhighlight %}

Continuar con el rebase una vez solucionados los conflictos
: {% highlight sh %}
    $ git rebase --continue
{% endhighlight %}

Abortar el rebase y volver a antes de su ejecución
: {% highlight sh %}
    $ git rebase --abort
{% endhighlight %}

Configurar pull rebase para una rama específica
: {% highlight sh %}
    $ git config branch.branch-name.rebase yes
{% endhighlight %}

Configurar pull rebase para ramas nuevas
: {% highlight sh %}
    $ git config --global branch.autosetuprebase remote|local|always
{% endhighlight %}

<br />

## Edición de commits 
> El objetivo es que cada commit tenga un objetivo específico al subirlo a origin. Mientras se trabaja se pueden subir commits temporales, pero antes de hacer push se deberían editar (corregir mensajes, subidas absurdas, etc.)

Cambiar el último commit borrando el commit anterior
: {% highlight sh %}
    $ git commit --amend
{% endhighlight %}

Rehacer el último commit borrado por accidente con amend
: {% highlight sh %}
$ git log -g
$ git checkout <commit_encontrado_con_historial_operaciones>
{% endhighlight %}

Deshechar los últimos n commits (p.61)
: {% highlight sh %}
$ git log -g
$ git reset HEAD~[n]
{% endhighlight %}

Deshacer commit añadiendo un nuevo commit, para que quede constancia en la historia (p.62)
: {% highlight sh %}
    $ git revert <hash_commit>
{% endhighlight %}

Rehacer la historia de commits (reordenar, split, join, etc)
: {% highlight sh %}
    $ git rebase -i HEAD~n (p.64)
{% endhighlight %}

Aplicar commit específico como commit actual
: {% highlight sh %}
    $ git cherry-pick (p.181)
{% endhighlight %}

---

# Ramas

Crear una nueva rama que apunta al commit actual y cambiar a esta
: {% highlight sh %}
    $ git checkout -b <nueva_rama>
{% endhighlight %}

O lo que es lo mismo
: {% highlight sh %}
$ git branch <nueva_rama>
$ git checkout <nueva_rama>
{% endhighlight %}

Crear una rama que comience en un commit particular y cambiar a esta
: {% highlight sh %}
    $ git checkout -b <nueva_rama> <hash_commit>
{% endhighlight %}

O lo que es lo mismo
: {% highlight sh %}
$ git checkout <hash_commit> (detached HEAD mode, no existe ninguna rama apuntando a este commit) (p.74)
$ git checkout -b <nueva_rama>
{% endhighlight %}

> Si las ramas no difieren (cuando creamos una rama nueva o después de hacer un merge entre 2 ramas), git no machacará los cambios no comitados. Los mantendrá para que los podamos aplicarlos en la nueva rama.

> Si las ramas difieren avisará con el mensaje:
    error: Your local changes to the following files would be overwritten by checkout: foo. Please, commit your changes or stash them before you can switch branches. Aborting

> La solución es hacer commit/stash, o utilizar git checkout --merge para mezclar a 3, dejando el resultado en el ```WORKING TREE``` (p.74)

Borrar una rama
: {% highlight sh %}
    $ git branch -d <nombre_rama>
{% endhighlight %}

Forzar el borrado de una rama que no está completamente mergeada (p. 75)
: {% highlight sh %}
    $ git branch -D <nombre_rama>
{% endhighlight %}

Ver rama upstream asociada a cada rama de nuestro repositorio
: {% highlight sh %}
$ git branch -vv (muestra el estado desde el último fetch)
$ git remote show origin (contactando con el remoto, más información)
{% endhighlight %}

Borrar rama del repositorio remoto
: {% highlight sh %}
    $ git push origin :rama_remoto
{% endhighlight %}

Forzar borrado en el repositorio local de las ramas borradas mediante el comando anterior en el remoto (es decir, actualizar el borrado en local)
: {% highlight sh %}
    $ git fetch --prune
{% endhighlight %}

---

# Stash

## Save stash
Save stash restoring working tree with last commit
: {% highlight sh %}
$ git stash save [<message>]
{% endhighlight %}
> Same as git stash (if you want to provide message ```save``` is mandatory)

> Saving stash implies ```git reset --hard```

Save stash but keep index intact
: {% highlight sh %}
$ git stash save --keep-index
{% endhighlight %}

Save stash including untracked files
: {% highlight sh %}
$ git stash save --include-untracked
{% endhighlight %}
> When stashing untracked files ```git clean``` is executed removing untracked files from working tree

> Use ```--all``` to stash and remove also ignored files

## Restore stash on Working Tree
Restore stash but don't drop stashed state
: {% highlight sh %}
$ git stash apply [--index] [<stashref>]
{% endhighlight %}
> Use ```git stash list``` to show stashes refs than can be applied and ```git stash show``` to see the changes

> Restore also index (if possible) with the ```--index``` option

Restore stash and drop stashed state
: {% highlight sh %}
$ git stash pop [--index] [<stashref>]
{% endhighlight %}
> If there are conflicts stash is not removed. Resolve and remove manually (see below)

## Removing stashes
Remove last stash (or the stash specified)
: {% highlight sh %}
$ git stash drop [<stashref>]
{% endhighlight %}

Remove all stashes
: {% highlight sh %}
$ git clear
{% endhighlight %}


---

# Submodules

Add submodule
: {% highlight sh %}
$ git submodule add <repo_url>
{% endhighlight %}

Remove Submodule
: {% highlight sh %}
# delete the relevant section from the .gitmodules file at the root of the parent project
$ git add .gitmodules
# delete the relevant section from the config file located in the .git directory at the root of the project
$ git rm --cached path/to/submodule
$ rm -rf .git/modules/submodule_name
$ git commit -m "Removed <vendor> submodule." # only necessary if submodule was comitted
$ rm -rf path/to/submodule
{% endhighlight %}

Update to fixed commit (on main repo) of submodules
: {% highlight sh %}
# update submodules
$ git submodule update --init --recursive
{% endhighlight %}

Pull in the changes from main repo and submodules
: {% highlight sh %}
$ git pull --recurse-submodules
{% endhighlight %}
> This is the same as: git pull + submodule update

Upgrade specific submodule to last commit
: {% highlight sh %}
$ cd bundle/<plugin>
$ git pull origin master
{% endhighlight %}

Upgrade all submodules of the current repo to their last commit
: {% highlight sh %}
$ git submodule foreach git pull origin master
{% endhighlight %}

